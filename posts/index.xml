<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Blog</title>
    <link>https://thomastrinn.github.io/blog/posts/</link>
    <description>Recent content in Posts on Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 22 Nov 2021 17:09:29 +0100</lastBuildDate><atom:link href="https://thomastrinn.github.io/blog/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Raspberry Pi 3 - Part 4: Docker Container Auto Update</title>
      <link>https://thomastrinn.github.io/blog/posts/pi3-server-part-04-docker-container-auto-update/</link>
      <pubDate>Mon, 22 Nov 2021 17:09:29 +0100</pubDate>
      
      <guid>https://thomastrinn.github.io/blog/posts/pi3-server-part-04-docker-container-auto-update/</guid>
      <description>Docker container-ben futó alkalmazásokat nem tudunk update-elni, mivel a docker container-ek immutable-ek. Ahhoz, hogy az alkalmazás újabb verzióját használhassuk szükségünk van egy docker image-re, amely tartalmazza az új verziót és a container-ünket törölnünk kell, majd az új image-el újra létre kell hoznunk.
Watchtower A watchtower segítségével automatizálhatjuk a docker container-jeink update-elési folyamatát.
A watchtower monitorozza a futó Docker container-jeinket, hogy a container-ek alapjáúl szolgáló image-k változtak-e. Ha úgy érzékeli, hogy volt változás, akkor automatikusan újraindítja az érintett containereket az új image-ekre épülve, megtartva az eredeti beállításokat (portok, stb.</description>
    </item>
    
    <item>
      <title>Raspberry Pi 3 - Part 3: Install docker and docker-compose</title>
      <link>https://thomastrinn.github.io/blog/posts/pi3-server-part-03-install-docker/</link>
      <pubDate>Sun, 21 Nov 2021 16:29:28 +0100</pubDate>
      
      <guid>https://thomastrinn.github.io/blog/posts/pi3-server-part-03-install-docker/</guid>
      <description>Docker telepítése Követve a hivatalos dokumentációt Raspbian esetén a convenience script segítségével telepíthetjük a Docker Engine-t.
curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh Docker kezelése non-root felhasználóval A docker parancs csak root jogosúltsággal használható, azaz csak a root userrel, vagy a sudo paranccsal.
Non-root user esetén, hogy a sudo használatát mellőzhessem ismét a hivatalos leírást követtem:
 Egy docker group létrehozása:  sudo groupadd docker A user felvétele a docker group-ba:  sudo usermod -aG docker $USER Log out és log in, hogy a group membership újra kiértékelődjön.</description>
    </item>
    
    <item>
      <title>Raspberry Pi 3 - Part 2: Auto update</title>
      <link>https://thomastrinn.github.io/blog/posts/pi3-server-part-02-auto-update/</link>
      <pubDate>Sun, 21 Nov 2021 14:04:04 +0100</pubDate>
      
      <guid>https://thomastrinn.github.io/blog/posts/pi3-server-part-02-auto-update/</guid>
      <description>Debian alapú rendszerek esetén az unattended-upgrades csomag biztosít lehetőséget update-ek automatikus futtatására.
Telepítés sudo apt-get install unattended-upgrades apt-listchanges -y Beállítások Az unattended-upgrades beállításait az /etc/apt/apt.conf.d/50unattended-upgrades fájl tartalmazza.
Lehetőségünk van beállítani az automatikus újraindítást, ha az update után az szükséges:
Unattended-Upgrade::Automatic-Reboot &amp;quot;true&amp;quot;; Továbbá lehetőségünk van e-mail értesítést is küldeni az alábbi két sorral:
Unattended-Upgrade::Mail &amp;quot;user@example.com&amp;quot;; Unattended-Upgrade::MailReport &amp;quot;on-change&amp;quot;; De ez csak akkor fog működni, ha a rendszer tud e-mail-t küldeni, ehhez pedig egy olyan tool-ra van szükségünk, ami a mailx package-t támogatja.</description>
    </item>
    
    <item>
      <title>Raspberry Pi 3 - Part 1: Setup</title>
      <link>https://thomastrinn.github.io/blog/posts/pi3-server-part-01-setup/</link>
      <pubDate>Tue, 09 Nov 2021 20:08:03 +0100</pubDate>
      
      <guid>https://thomastrinn.github.io/blog/posts/pi3-server-part-01-setup/</guid>
      <description>Az OS telepítése A célom hogy headless módon használhassam a pi-t, így nincs szükségem desktop enviromentre. Követve a hivatalos getting started leírást, az OS-t a Raspberry Pi Imager segítségével telepítem.
Miután az SD kártyát a számítógépemhez csatlakoztattam az RP Imager-ben OS-ként nem a default beállítást választottam, hanem az other opció alatt elérhető DE nélküli változatot (ebből két verzió létezik: Lite és Full, az utóbbit választottam).
Az Advanced Options segítségével be tudtam állítani a wifi-t, a locale beállításokat és az ssh-t.</description>
    </item>
    
    <item>
      <title>Get Started With Docker Compose</title>
      <link>https://thomastrinn.github.io/blog/posts/get-started-with-docker-compose/</link>
      <pubDate>Fri, 06 Aug 2021 08:23:05 +0200</pubDate>
      
      <guid>https://thomastrinn.github.io/blog/posts/get-started-with-docker-compose/</guid>
      <description>A Docker Compose egy olyan eszköz, aminek segítségével definiálni és elindítani tudunk több docker container-t.
Docker Compose fájlok A docker-compose.yml fájl tartalmazza azon service-eket amelyeket docker container-ként akarunk futtatni.
A .env fájl nem kötelező, de ha használjuk, akkor környezeti változókat tartalmazhat, amelyek a docker-compose.yml fájlban behivatkozhatóak. További részletek itt találhatóak.
Rendelkezésre állnak előre definiált környezeti változók, amelyekkel finomhangolhatjuk a Docker Compose működését. Az egyik ilyen környezeti változó a COMPOSE_PROJECT_NAME, amellyel a projektünk nevét adhatjuk meg, amit a docker-compose utána felhasznál prefixként a létrehozandó container-ek, volume-ok, network-ok nevéhez.</description>
    </item>
    
    <item>
      <title>Elasticsearch in Docker</title>
      <link>https://thomastrinn.github.io/blog/posts/elasticsearch-in-docker/</link>
      <pubDate>Fri, 06 Aug 2021 08:09:59 +0200</pubDate>
      
      <guid>https://thomastrinn.github.io/blog/posts/elasticsearch-in-docker/</guid>
      <description>Az alábbi docker-compose.yml fájl egy elasticsearch és egy elastickibana service-t indít el.
version: &amp;#39;3&amp;#39; services: elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch:7.9.3 container_name: ebla_elasticsearch environment: - xpack.security.enabled=false - discovery.type=single-node ulimits: memlock: soft: -1 hard: -1 nofile: soft: 65536 hard: 65536 cap_add: - IPC_LOCK volumes: - elasticsearch_data:/usr/share/elasticsearch/data ports: - 9200:9200 - 9300:9300 kibana: image: docker.elastic.co/kibana/kibana:7.9.3 container_name: ebla_kibana environment: - ELASTICSEARCH_HOSTS=http://elasticsearch:9200 ports: - 5601:5601 depends_on: - elasticsearch volumes: elasticsearch_data: driver: local Ezen beállítások development környezetre ajánlatosak, production esetén ez kerülendő.</description>
    </item>
    
    <item>
      <title>SonarQube in Docker</title>
      <link>https://thomastrinn.github.io/blog/posts/sonarqube-in-docker/</link>
      <pubDate>Fri, 06 Aug 2021 07:54:46 +0200</pubDate>
      
      <guid>https://thomastrinn.github.io/blog/posts/sonarqube-in-docker/</guid>
      <description>A SonarQube egy kód minőség elemző eszköz.
SonarQube futtatása docker-compose service-ként docker-compose.yml:
version: &amp;#34;3&amp;#34; services: sonarqube: image: sonarqube:8.9-community container_name: sonarqube depends_on: - db ulimits: memlock: soft: -1 hard: -1 nofile: soft: 65536 hard: 65536 environment: SONAR_JDBC_URL: jdbc:postgresql://db:5432/sonar SONAR_JDBC_USERNAME: sonar SONAR_JDBC_PASSWORD: sonar volumes: - sonarqube_data:/opt/sonarqube/data - sonarqube_extensions:/opt/sonarqube/extensions - sonarqube_logs:/opt/sonarqube/logs ports: - &amp;#34;9010:9000&amp;#34; db: image: postgres:12 container_name: sonarqube-postgres environment: POSTGRES_USER: sonar POSTGRES_PASSWORD: sonar ports: - 14432:5432 volumes: - postgresql:/var/lib/postgresql - postgresql_data:/var/lib/postgresql/data volumes: sonarqube_data: sonarqube_extensions: sonarqube_logs: postgresql: postgresql_data: SonarQube indítása: docker-compose up -d</description>
    </item>
    
    <item>
      <title>PostgreSQL in Docker</title>
      <link>https://thomastrinn.github.io/blog/posts/postgresql-in-docker/</link>
      <pubDate>Wed, 04 Aug 2021 08:04:34 +0200</pubDate>
      
      <guid>https://thomastrinn.github.io/blog/posts/postgresql-in-docker/</guid>
      <description>PostgreSQL server könnyen indítható docker container segítségével. A container létrehozását docker-compose segítségével végzem.
PostgreSQL docker-compose service Ahhoz, hogy docker-compose segítségével hozzunk létre a postgresql docker containert két fájlra lesz szükségünk. Az egyik a .env fájl a másik a docker-compose.yml.
A .env fájl nem kötelező, de praktikus, itt környezeti változókat definiálhatunk, amelyeket a docker-compose.yml fájlban fel tudunk használni.
A docker-compose.yml fájlban definiáljuk a service-ket a volumes-eket. Jelen esetben csak egy service-t definiálunk, a postgresql-t.</description>
    </item>
    
    <item>
      <title>Linux Systemd Journal</title>
      <link>https://thomastrinn.github.io/blog/posts/linux-systemd-journal/</link>
      <pubDate>Tue, 03 Aug 2021 14:27:25 +0200</pubDate>
      
      <guid>https://thomastrinn.github.io/blog/posts/linux-systemd-journal/</guid>
      <description>Journal mérete A journal a /var/log/journal/ könyvtárba hozza létre a log fájlokat, amik idővel sok helyet foglalhatnak. Ennek határt szabhatunk.
A /etc/systemd/journald.conf fájlban a SystemMaxUse változónak értéket adhatunk:
SystemMaxUse=50M A config fájl módosítását követően a journal service-t újra kell indítanunk, hogy a változtatások érvényesüljenek:
systemctl restart systemd-journald Hibák megtekintése Az alábbi paranccsal a log-ban levő hibákat tekinthetjük meg:
journalctl -r -p 3 További részletek: arch wiki journal</description>
    </item>
    
  </channel>
</rss>
